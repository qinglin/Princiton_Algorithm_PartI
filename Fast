import java.io.File;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;


public class Fast {
	private Point[] points;
	public Fast(){
		
	}
	private void getPoints(Point[] points) {
		this.points = points;
	}
	
	private void mergeSort(Point[] points, Comparator<Point> comparator) {
		Point[] aux = new Point[points.length];
		Sort(points,aux,0,points.length-1,comparator);
	
}
	
	private void Sort(Point[] objects, Point[] aux, int low, int high, Comparator<Point> comparator) {
		if (low >= high) return ;
		else {
			int mid = low + (high - low)/2;
			
			Sort(objects,aux, low,mid, comparator);
			Sort(objects,aux, mid+1,high,comparator);
			Merge(objects,aux,comparator,low,mid,high);
		}
		
	}
	
	private void Merge(Point[] obj, Point[] aux, Comparator<Point> comparator, int low, int mid, int high ) {
		int i = low; 
		int j = mid + 1;
		for ( int k = low; k<= high; k++ ) {
			aux[k] = obj[k];}
		for ( int k = low; k<= high; k++ ) {
			if ( i > mid ) obj[k] = aux[j++];
			else if (j > high ) obj[k] = aux[i++];
			else if (less(aux[j],aux[i],comparator)) {
				obj[k] = aux[j++];
			}
			else obj[k] = aux[i++];
		}
		}
	
	private boolean less(Point a, Point b, Comparator<Point> comparator) {
//		StdOut.println(comparator.compare(a, b) < 0);
		return comparator.compare(a, b) < 0;
		
	}
	
	private LinkedList<Point> isCollinear(int k, Point[] sortedPoints) {
		LinkedList<Point> ps = new LinkedList<Point>(); 
		double slope = 0;
		int length = 0;
		double preSlope = 0;
		ps.add(sortedPoints[k]);
		for (int i = 0 ; i < sortedPoints.length ; i++) {
			slope = sortedPoints[k].slopeTo(sortedPoints[i]);
			if( i == 0) {
				preSlope = slope;
				if(!ps.contains(sortedPoints[i])) {
					ps.add(sortedPoints[i]);
					length++;
				}
				}
			else if (( i > 0 && slope == preSlope) || (i > 0 && slope == Double.POSITIVE_INFINITY && preSlope == Double.POSITIVE_INFINITY)|| (i > 0 && slope == Double.NEGATIVE_INFINITY && preSlope == Double.NEGATIVE_INFINITY)) {
				if(!ps.contains(sortedPoints[i-1])) {
					ps.add(sortedPoints[i-1]);
					length++;
					}
					ps.add(sortedPoints[i]);
					length ++;
			}
		
			else {
				if(length < 4) {
					ps = new LinkedList<Point>();
					ps.add(sortedPoints[k]);
					length = 1;
					preSlope = slope;
				}
				else {
					return ps;
				}
				
				
			}
		}	
		return ps;
	}
	
	private Point[] Sort(int size, LinkedList<Point> points){
		Point[] ps = new Point[size];
		Iterator<Point> it = points.iterator();
		int k = 0;
		while(it.hasNext()){
			ps[k++] = it.next();
		}
		
		// Insertion Sort
		for (int i = 0; i< size - 1; i++) {
			int j =  i + 1;
			while(j >= 0 && i >= 0 && ps[i].compareTo(ps[j]) > 0) {
					Point temp = ps[i];
					ps[i--] = ps[j];
					ps[j--] = temp;
		}
	
		}
		
		return ps;
	}
	
	private boolean isSubset (LinkedList<Point> points, ArrayList<Point[]> arrayPoints) {
		boolean isSubset = true;
		boolean containsPoint = false;
		if(arrayPoints.size() == 0) isSubset = false;
		else {
			for(int i = 0; i< arrayPoints.size();i++) {
				Point[] ps = arrayPoints.get(i);
				Iterator<Point> it = points.iterator();
				isSubset = true;
				while(it.hasNext()) {
					Point p = it.next();
					containsPoint = false;
					for(int j = 0; j< ps.length; j++){
						if (ps[j].compareTo(p) == 0) containsPoint = true ;
						
					}
					isSubset = isSubset && containsPoint;
				}
				if(isSubset) {
					return isSubset;
				}
			}
		}

		return isSubset;
				
	} 
	
	public static void main(String args[]){
		In in = new In(new File(args[0]));
		int lineNum = 0;
		int i = 0;
		if (in.hasNextLine()) {
			lineNum = in.readInt();
		}
		in.readLine();
		Point[] points = new Point[lineNum];
		while (in.hasNextLine()) {
			int x = in.readInt();
			int y = in.readInt();
			in.readLine();
			points[i] = new Point(x,y);
			StdDraw.setXscale(0, 32768);
			StdDraw.setYscale(0, 32768);
			points[i++].draw(); 
		}
		
		Fast f = new Fast();
		f.getPoints(points);
//		points = f.mergeSort(points, points[0].SLOPE_ORDER);

		String s = null;
		int length = 0;
		Point[] pois = null;
		Point[] Unsorted = new Point[lineNum];
		for(int u = 0 ; u < lineNum ; u++ ) {
			Unsorted[u] = points[u];
		}
		ArrayList<Point[]> arrayPoints = new ArrayList<Point[]>();
		for(int k = 0 ; k < lineNum ; k++ ) {
//			StdOut.println("k: "+Unsorted[k].toString());
			for(int u = 0 ; u < lineNum ; u++ ) {
				points[u] = Unsorted[u];
			}
//			for(int t = 0; t< points.length; t++) {
//				StdOut.println(Unsorted[k].slopeTo(points[t]));
//				}
			f.mergeSort(points, Unsorted[k].SLOPE_ORDER);
//			for(int t = 0; t< points.length ; t++) {
//				StdOut.println(Unsorted[k].slopeTo(points[t]));
//				}
//			StdOut.println();
			LinkedList<Point> ps = f.isCollinear(0, points);
			
			if(ps.size() >= 4 ){
				if(ps.size() <= length) {
					if(f.isSubset(ps,arrayPoints)) continue;
				}
				if(ps.size() > length){
				length = ps.size();}
				pois = new Point[length];
				
				pois = f.Sort(ps.size(), ps);
				arrayPoints.add(pois);
				s = pois[0].toString();
				for(int j = 1; j< pois.length; j++) {
					 s += " -> " + pois[j].toString();
			 }
				StdOut.println(s);
				StdDraw.setXscale(0, 32768);
				StdDraw.setYscale(0, 32768);
				pois[0].drawTo(pois[pois.length - 1]);
			}
		}
		
		
	}
}
